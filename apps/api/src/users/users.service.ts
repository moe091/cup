import { BadRequestException, ConflictException, Injectable, NotFoundException } from '@nestjs/common';
import type { UserProfile } from '@cup/shared-types';
import { PrismaService } from 'src/prisma/prisma.service';
import type { UpdateUserProfileInput } from './users.types';

@Injectable()
export class UsersService {
  constructor(private readonly prisma: PrismaService) {}

  async getMe(userId: string): Promise<UserProfile> {
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
      select: { id: true, username: true, usernameAutoGenerated: true, email: true, displayName: true },
    });

    if (!user) {
      throw new NotFoundException('User not found');
    }

    return user;
  }

  async updateMe(userId: string, payload: unknown): Promise<UserProfile> {
    const updates = this.parseUpdatePayload(payload);

    if (updates.username !== undefined) {
      const existing = await this.prisma.user.findUnique({
        where: { username: updates.username },
        select: { id: true },
      });

      if (existing && existing.id !== userId) {
        throw new ConflictException('username is already taken');
      }
    }

    if (updates.email !== undefined && updates.email !== null) {
      const existing = await this.prisma.user.findUnique({
        where: { email: updates.email },
        select: { id: true },
      });

      if (existing && existing.id !== userId) {
        throw new ConflictException('email is already in use');
      }
    }

    const user = await this.prisma.user.update({
      where: { id: userId },
      data: {
        ...(updates.username !== undefined ? { username: updates.username, usernameAutoGenerated: false } : {}),
        ...(updates.displayName !== undefined ? { displayName: updates.displayName } : {}),
        ...(updates.email !== undefined ? { email: updates.email } : {}),
      },
      select: { id: true, username: true, usernameAutoGenerated: true, email: true, displayName: true },
    });

    return user;
  }

  private parseUpdatePayload(payload: unknown): UpdateUserProfileInput {
    if (!payload || typeof payload !== 'object' || Array.isArray(payload)) {
      throw new BadRequestException('Invalid request body');
    }

    const body = payload as Record<string, unknown>;
    const updates: UpdateUserProfileInput = {};

    if (Object.prototype.hasOwnProperty.call(body, 'username')) {
      updates.username = this.validateUsername(body.username);
    }

    if (Object.prototype.hasOwnProperty.call(body, 'displayName')) {
      updates.displayName = this.validateDisplayName(body.displayName);
    }

    if (Object.prototype.hasOwnProperty.call(body, 'email')) {
      updates.email = this.validateEmail(body.email);
    }

    return updates;
  }

  private validateUsername(value: unknown): string {
    if (typeof value !== 'string') {
      throw new BadRequestException('username must be a string');
    }

    const username = value.trim();
    if (!/^[a-zA-Z0-9_]{3,24}$/.test(username)) {
      throw new BadRequestException('username must be 3-24 characters using letters, numbers, or _');
    }

    return username;
  }

  private validateDisplayName(value: unknown): string | null {
    if (value === null || value === undefined) {
      return null;
    }

    if (typeof value !== 'string') {
      throw new BadRequestException('displayName must be a string');
    }

    const trimmed = value.trim();
    if (!trimmed) {
      return null;
    }

    if (trimmed.length > 50) {
      throw new BadRequestException('displayName must be 50 characters or less');
    }

    return trimmed;
  }

  private validateEmail(value: unknown): string | null {
    if (value === null || value === undefined) {
      return null;
    }

    if (typeof value !== 'string') {
      throw new BadRequestException('email must be a string');
    }

    const email = value.trim().toLowerCase();
    if (!email) {
      return null;
    }

    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      throw new BadRequestException('email format is invalid');
    }

    return email;
  }
}
